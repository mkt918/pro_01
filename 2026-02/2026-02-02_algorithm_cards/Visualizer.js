export class Visualizer {
    constructor(deck, callbacks) {
        this.deck = deck;
        this.callbacks = callbacks; // { onUpdate: ({message, state}) => void, onFinished: () => void }

        this.generator = null;
        this.history = []; // Store snapshots of state to allow stepping back? 
        // Stepping back in a mutation-based visualizer is hard. 
        // Alternative: Re-run from start up to Step N-1.
        // For simplicity: Support Step Forward only first, Step Back by re-running if needed or just disable it.
        // Plan says "Step Forward/Back". Re-running is robust.

        this.currentStepIndex = -1;
        this.steps = []; // Store the sequence of steps generated by the algorithm if we pre-calculate.
        // OR generate dynamically. Pre-calculation is easier for "Step Back".

        this.isPlaying = false;
        this.speed = 500; // ms
        this.timer = null;
    }

    setAlgorithm(algorithmFn, ...args) {
        this.reset();
        this.steps = [];

        // 1. Create Simulation Deck (Shallow copy of cards array is enough for swap-based algos)
        const simDeck = [...this.deck.cards];

        // 2. Initialize Algorithm with Simulation Deck
        const gen = algorithmFn(simDeck, ...args);

        // 3. Generate Steps from Generator
        let result = gen.next();
        while (!result.done) {
            this.steps.push(result.value);
            result = gen.next();
        }

        this.steps.push({ type: 'finished', message: '完了 (Finished)' });
        console.log(`Planned ${this.steps.length} steps.`);
    }

    reset() {
        this.pause();
        this.currentStepIndex = -1;
        this.isPlaying = false;
        // We need to reset the Deck to initial state? 
        // The main app should handle deck reset before setting algorithm.
    }

    start() {
        if (this.currentStepIndex < this.steps.length - 1) {
            this.stepForward();
        }
    }

    play() {
        if (this.isPlaying) return;
        this.isPlaying = true;
        this.loop();
    }

    pause() {
        this.isPlaying = false;
        clearTimeout(this.timer);
    }

    loop() {
        if (!this.isPlaying) return;

        if (this.currentStepIndex >= this.steps.length - 1) {
            this.pause();
            return;
        }

        this.stepForward();

        const delay = 10000 / (this.speed * 2); // Speed 1-10 -> Delay 5000ms to 500ms?
        // Let's map speed 1(slow) to 2000ms, 10(fast) to 200ms.
        // speed 5 -> 1000ms?
        // User passed 1-10.
        // speed ms = 2000 / speed_val?
        // 1 -> 2000, 10 -> 200.

        const s_val = typeof this.speed === 'number' ? this.speed : 5;
        const ms = 2200 - (s_val * 200);

        this.timer = setTimeout(() => this.loop(), Math.max(100, ms));
    }

    setSpeed(val) {
        this.speed = val;
    }

    stepForward() {
        if (this.currentStepIndex >= this.steps.length - 1) return;
        this.currentStepIndex++;
        this.applyStep(this.steps[this.currentStepIndex]);
    }

    stepBack() {
        if (this.currentStepIndex < 0) return;

        // To step back, we need to revert the current step.
        const step = this.steps[this.currentStepIndex];
        this.revertStep(step);

        this.currentStepIndex--;

        // If we went back to -1, we are at start.
        // But we need to "re-apply" the state of step -1? No, step -1 is "initial".
        if (this.currentStepIndex >= 0) {
            // We highlight the previous step's state?
            // Actually, just revert is enough to undo layout. 
            // But highlights need to match the previous step.
            // Easiest: Revert current, then Apply previous (just for highlights).
            const prevStep = this.steps[this.currentStepIndex];
            this.applyStep(prevStep, false); // false means 'don't apply logic, just highlight'
        } else {
            // Clear highlights with null check
            this.deck.cards.forEach(c => {
                if (c && c.removeHighlights) c.removeHighlights();
            });
            this.callbacks.onUpdate({ message: '準備完了 (Ready)', codeLine: null });
        }
    }

    applyStep(step, applyLogic = true) {
        // Clear all highlights first (with null check for 1-based indexing)
        this.deck.cards.forEach(c => {
            if (c && c.removeHighlights) c.removeHighlights();
        });

        // Common info update
        this.callbacks.onUpdate({
            message: step.message,
            variables: step.variables,
            codeLine: step.codeLine
        });

        // Apply specific actions
        switch (step.type) {
            case 'compare':
                step.indices.forEach(i => this.deck.cards[i].highlight('compare'));
                break;
            case 'swap':
                const { indexA, indexB } = step;
                this.deck.cards[indexA].highlight('swap');
                this.deck.cards[indexB].highlight('swap');
                if (applyLogic) {
                    // Determine direction for animation if needed
                    // For now, just swap via Deck (which updates DOM order)
                    // But wait, our 'this.deck.cards' is the LIVE array.
                    // We must swap them in the deck array AND the DOM.

                    // Helper to swap visually and logically
                    const cardA = this.deck.cards[indexA];
                    const cardB = this.deck.cards[indexB];

                    // Swap in array
                    [this.deck.cards[indexA], this.deck.cards[indexB]] = [this.deck.cards[indexB], this.deck.cards[indexA]];

                    // Swap in DOM
                    const parent = cardA.element.parentNode;
                    // Basic swap logic: insert B before A? 
                    // Since we rebuilt the array, we can just re-append everything? 
                    // Or swap nodes.
                    // Re-rendering is safest for order.
                    this.deck.render(parent);

                    // Re-add highlights because render clears DOM
                    this.deck.cards[indexA].highlight('swap'); // New indexA (was B)
                    this.deck.cards[indexB].highlight('swap'); // New indexB (was A)
                }
                break;
            case 'select':
                step.indices.forEach(i => this.deck.cards[i].highlight('selected'));
                break;
            case 'sorted':
                step.indices.forEach(i => this.deck.cards[i].highlight('sorted'));
                break;
            case 'found':
                step.indices.forEach(i => this.deck.cards[i].highlight('sorted')); // or specific 'found' style
                break;
            case 'to_hozon':
                {
                    const { index, value } = step;
                    // Provide a card specific for hozon representation
                    // We can reuse the card object from deck logic or create a proxy
                    // Value is enough to show it.
                    // But to keep consistency (suit/color), we should ideally grab the actual card object.
                    const card = this.deck.cards[index];
                    this.deck.setHozon(card);
                    // Optionally 'fade' the card in the array to show it's moved? (Optional)
                }
                break;
            case 'from_hozon':
                {
                    const { index, value } = step;
                    // Copy from hozon to deck[index]
                    // Ideally the logic already updated the deck array via swap/shift loop or final assignment
                    // Just render the deck updates if needed.
                    // If this step implies "Overwrite aaa[index] with hozon value"

                    if (applyLogic) {
                        // Logic handles array update?
                        // If logic is handled in generator, we just reflect it.
                        // For insertion sort, we need to ensure the final placement is visualized.
                        // But usually we just re-render 'setHozon(null)' to clear hozon?
                        // Or keep it until next loop.
                    }
                    // Maybe clearing hozon is a separate explicit step or handled here?
                    // Let's assume we keep it visible for clarity logic.
                }
                break;
            case 'clear_hozon':
                this.deck.setHozon(null);
                break;
            case 'to_max':
                {
                    const { index } = step;
                    const card = this.deck.cards[index];
                    this.deck.setMax(card);
                }
                break;
            case 'to_min':
                {
                    const { index } = step;
                    const card = this.deck.cards[index];
                    this.deck.setMin(card);
                }
                break;
            case 'clear_max':
                this.deck.setMax(null);
                break;
            case 'clear_min':
                this.deck.setMin(null);
                break;
            case 'to_foundAt':
                {
                    const { index } = step;
                    const card = this.deck.cards[index];
                    this.deck.setFoundAt(card);
                }
                break;
            case 'clear_foundAt':
                this.deck.setFoundAt(null);
                break;
        }
    }

    revertStep(step) {
        // Undo logic changes
        if (step.type === 'swap') {
            const { indexA, indexB } = step;
            // Swap back (indexA and indexB are the indices used in the Forward step)
            // Forward: Swap(i, j).
            // Array became [ ..., j, ..., i, ... ] (conceptually)
            // Undo: Swap(i, j) again?
            // YES. Swapping is its own inverse.

            // Note: indexA and indexB refer to positions.
            // Since we swapped the content at these positions, swapping them again restores order.

            [this.deck.cards[indexA], this.deck.cards[indexB]] = [this.deck.cards[indexB], this.deck.cards[indexA]];
            // Re-render with null-safe parent access
            const firstCard = this.deck.cards.find(c => c !== null);
            if (firstCard && firstCard.element && firstCard.element.parentNode) {
                this.deck.render(firstCard.element.parentNode);
            } else {
                this.deck.render();
            }
        }
        // Compare/Select/Sorted don't change logic state, only visuals.
    }
    highlightCode(lineNum, type) {
        if (this.callbacks && this.callbacks.highlightCode) {
            this.callbacks.highlightCode(lineNum, type);
        }
    }
}
